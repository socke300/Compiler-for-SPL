package de.thm.mni.compilerbau.phases._02_03_parser;

import java_cup.runtime.*;
import de.thm.mni.compilerbau.utils.*;
import de.thm.mni.compilerbau.absyn.*;
import de.thm.mni.compilerbau.table.Identifier;
import de.thm.mni.compilerbau.utils.SplError;

parser code {:
  public void syntax_error(Symbol currentToken) {
    throw SplError.SyntaxError(new Position(currentToken.left, currentToken.right));
  }
:}

/* Terminals/Tokens */
terminal LBRACK, RBRACK, LPAREN, RPAREN, LCURL, RCURL;         //Braces, parenthesis, brackets
terminal LT, LE, GT, GE, NE, EQ;                               //Comparison operators
terminal PLUS, MINUS, STAR, SLASH;                             //Arithmetic operators
terminal ASGN, COMMA, COLON, SEMIC;                            //Other delimiters
terminal TYPE, PROC, ARRAY, OF, REF, VAR, IF, ELSE, WHILE;     //Keywords
terminal String IDENT;                                     //Identifiers
terminal Integer INTLIT;                                       //Integer literals

/* Non-terminals */
non terminal Program program;
non terminal List<GlobalDeclaration> globalDeclarations;
non terminal GlobalDeclaration globalDeclaration;
non terminal TypeDeclaration typeDeclaration;
non terminal ProcedureDeclaration proc;
non terminal List<ParameterDeclaration> parameterList;
non terminal ParameterDeclaration parameterDeclaration;
non terminal List<Statement> statementList;
non terminal Statement statement;
non terminal Expression expression;
non terminal AssignStatement assignmentStatement;
non terminal BinaryExpression.Operator comparisonOperator;
non terminal Expression factor;
non terminal IfStatement ifStatement;
non terminal CallStatement procCall;
non terminal List<Expression> argumentList;
non terminal VariableDeclaration varDeclaration;
non terminal WhileStatement whileStatement;
non terminal TypeExpression typeExpression;
non terminal List<VariableDeclaration> variableList;
non terminal Variable variable;
non terminal Expression addexpression;
non terminal Expression mulExpression;
non terminal BinaryExpression booleanExpression;

//GLOBAL
start with program;
program ::= globalDeclarations:gDec {: RESULT = new Program(new Position(gDecleft,gDecright),gDec);:};
globalDeclarations ::= globalDeclaration:head globalDeclarations:tails {: RESULT = new List(head,tails);:}
                     | {: RESULT =  List.nil();:} ;

globalDeclaration ::= typeDeclaration:td {: RESULT = td;:}
                    | proc:p {: RESULT = p;:};



//types
typeDeclaration ::= TYPE IDENT:name EQ typeExpression:te SEMIC {: RESULT = new TypeDeclaration(new Position(nameleft,nameright),new Identifier(name), te);:};
typeExpression ::= ARRAY:ar LBRACK INTLIT:size RBRACK OF typeExpression:base {: if(size != null) RESULT = new ArrayTypeExpression(new Position(arleft,arright), base, size);:}
                 | IDENT:name {: RESULT = new NamedTypeExpression(new Position(nameleft,nameright), new Identifier(name));:};


//Procs
proc ::= PROC:p IDENT:name LPAREN parameterList:pList RPAREN LCURL variableList:vList statementList:sList RCURL {: RESULT = new ProcedureDeclaration(new Position(pleft,pright),new Identifier(name), pList, vList, sList);:};
parameterList ::= parameterDeclaration:pd COMMA parameterList:end {: RESULT = new List(pd,end); :}
                | parameterDeclaration:pd {: RESULT = new List(pd,List.nil()); :}
                |  {: RESULT = List.nil(); :};
parameterDeclaration ::= IDENT:name COLON typeExpression:te {: RESULT =  new ParameterDeclaration(new Position(nameleft,nameright), new Identifier(name), te, false);:}
                       | REF IDENT:name COLON typeExpression:te {: RESULT =  new ParameterDeclaration(new Position(nameleft,nameright), new Identifier(name), te, true);:};

procCall ::= IDENT:name LPAREN argumentList:argList RPAREN SEMIC{: RESULT = new CallStatement(new Position(nameleft,nameright), new Identifier(name),argList);:};

argumentList ::= addexpression:head COMMA argumentList:tail {:RESULT = new List(head,tail);:}
               | addexpression:head {:RESULT = new List(head,List.nil());:}
               | {:RESULT = List.nil();:};


//Variables
variableList ::= varDeclaration:vD variableList:tail {: RESULT = new List(vD,tail);:}
                | {: RESULT =  List.nil();:};

varDeclaration ::= VAR IDENT:name COLON typeExpression:te SEMIC{: RESULT = new VariableDeclaration(new Position(nameleft,nameright), new Identifier(name), te);:};

booleanExpression ::= addexpression:opl comparisonOperator:op addexpression:opr {: RESULT = new BinaryExpression(new Position(opleft, opright) , op, opl, opr); :};


//STATEMENT
statementList ::= statement:head statementList:tail {: RESULT = new List(head,tail);:}
                | {: RESULT = List.nil(); :};

statement ::= assignmentStatement:as {: RESULT = as; :}
            | ifStatement:is
            | procCall:pc {: RESULT = pc; :}
            | LCURL statementList:sL RCURL {:RESULT = new CompoundStatement(new Position(sLleft, sLright), sL);:}
            | SEMIC:sm {:RESULT = new EmptyStatement(new Position(smleft, smright));:}
            | whileStatement:ws {: RESULT = ws; :};

assignmentStatement ::= variable:target ASGN addexpression:value SEMIC {: RESULT = new AssignStatement(new Position(targetleft,targetright),target,value);:};
ifStatement ::= IF:ifs LPAREN booleanExpression:condition RPAREN statement:thenPart {: RESULT = new IfStatement(new Position(ifsleft,ifsright),condition,thenPart, new EmptyStatement(Position.ERROR_POSITION) );:}
              | IF:ifs LPAREN booleanExpression:condition RPAREN statement:thenPart ELSE statement:elsePart {: RESULT = new IfStatement(new Position(ifsleft,ifsright),condition,thenPart,elsePart);:};

whileStatement ::= WHILE:w LPAREN booleanExpression:excon RPAREN statement:body {: RESULT = new WhileStatement(new Position(wleft,wright),excon,body);:};



//OPERATOR
comparisonOperator ::= LT {: RESULT = BinaryExpression.Operator.LST; :}
                     | LE {: RESULT = BinaryExpression.Operator.LSE; :}
                     | GT {: RESULT = BinaryExpression.Operator.GRT; :}
                     | GE {: RESULT = BinaryExpression.Operator.GRE; :}
                     | NE {: RESULT = BinaryExpression.Operator.NEQ; :}
                     | EQ {: RESULT = BinaryExpression.Operator.EQU; :};

//OTHER
addexpression ::= addexpression:ae PLUS mulExpression:me {:RESULT = new BinaryExpression(new Position(aeleft, aeright), BinaryExpression.Operator.ADD, ae, me);:}
                | addexpression:ae MINUS mulExpression:me {:RESULT = new BinaryExpression(new Position(aeleft, aeright), BinaryExpression.Operator.SUB, ae, me);:}
                | mulExpression:me {:RESULT = me;:};
mulExpression ::= mulExpression:me STAR factor:fa {:RESULT = new BinaryExpression(new Position(meleft, meright), BinaryExpression.Operator.MUL, me, fa);:}
                | mulExpression:me SLASH factor:fa {:RESULT = new BinaryExpression(new Position(meleft, meright), BinaryExpression.Operator.DIV, me, fa);:}
                | factor:fa {:RESULT = fa;:};
factor ::= expression:ex {: RESULT = ex;:}
         | MINUS factor:f {: RESULT = f;:} ;

expression ::= INTLIT:value {:if(value != null) RESULT = new IntLiteral(new Position(valueleft,valueright),value);:}
             | variable:v {: RESULT = new VariableExpression(new Position(vleft,vright),v) ;:}
             | LPAREN addexpression:ae RPAREN {: RESULT = ae;:};
variable ::= IDENT:name {:RESULT = new NamedVariable(new Position(nameleft,nameright),new Identifier(name));:}
           | variable:array LBRACK addexpression:index RBRACK {:RESULT = new ArrayAccess(new Position(arrayleft,arrayright), array, index);:};





