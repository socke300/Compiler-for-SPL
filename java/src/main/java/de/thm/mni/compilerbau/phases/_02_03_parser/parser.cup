package de.thm.mni.compilerbau.phases._02_03_parser;

import java_cup.runtime.*;
import de.thm.mni.compilerbau.utils.*;
import de.thm.mni.compilerbau.absyn.*;
import de.thm.mni.compilerbau.table.Identifier;
import de.thm.mni.compilerbau.utils.SplError;

parser code {:
  public void syntax_error(Symbol currentToken) {
    throw SplError.SyntaxError(new Position(currentToken.left, currentToken.right));
  }
:}

/* Terminals/Tokens */
terminal LBRACK, RBRACK, LPAREN, RPAREN, LCURL, RCURL;         //Braces, parenthesis, brackets
terminal LT, LE, GT, GE, NE, EQ;                               //Comparison operators
terminal PLUS, MINUS, STAR, SLASH;                             //Arithmetic operators
terminal ASGN, COMMA, COLON, SEMIC;                            //Other delimiters
terminal TYPE, PROC, ARRAY, OF, REF, VAR, IF, ELSE, WHILE;     //Keywords
terminal Identifier IDENT;                                     //Identifiers
terminal Integer INTLIT;                                       //Integer literals

/* Non-terminals */
non terminal Program program;
non terminal List<GlobalDeclaration> globalDeclarations;
non terminal GlobalDeclaration globalDeclaration;
non terminal TypeDeclaration typeDeclaration;
non terminal ProcedureDeclaration procedure;
non terminal List<ParameterDeclaration> parameterList;
non terminal ParameterDeclaration parameterDeclaration;
non terminal CompoundStatement statementList;
non terminal Statement statement;
non terminal Expression expression;
non terminal AssignStatement assignmentStatement;
non terminal BinaryExpression.Operator comparisonOperator;
non terminal factor; //---------------------------------
non terminal IfStatement ifStatement;
non terminal CallStatement functionStatement;
non terminal List<Expression> argumentList;
non terminal VariableDeclaration varDeclaration;
non terminal WhileStatement whileStatement;
non terminal TypeExpression typeExpression;
non terminal List<Variable> variableList;
non terminal Variable variable;
non terminal Expression addexpression;
non terminal Expression mulExpression;
non terminal BinaryExpression booleanExpression;

//GLOBAL
start with program;
program ::= globalDeclarations:gd {: RESULT = new Program(new Position(gdleft,gdright), gd);:};
globalDeclarations ::= globalDeclaration globalDeclarations | ;
globalDeclaration ::= typeDeclaration:td {: RESULT = td;:}
                    | procedure;

//DECLARATION
typeDeclaration ::= TYPE IDENT:id EQ typeExpression:ex SEMIC {: RESULT = new TypeDeclaration(new Position(exleft,exright),id ,ex); :};
parameterDeclaration ::= IDENT COLON typeExpression | REF IDENT COLON typeExpression;
varDeclaration ::= VAR IDENT COLON typeExpression SEMIC;

//EXPRESSION
typeExpression ::= ARRAY LBRACK INTLIT RBRACK OF typeExpression
                 | IDENT;

booleanExpression ::= addexpression:opl comparisonOperator:op addexpression:opr {: RESULT = new BinaryExpression(new Position(opleft, opright) , op, opl, opr); :};

//STATEMENT
statement ::= assignmentStatement | ifStatement | functionStatement | LCURL statementList RCURL | SEMIC | whileStatement;
assignmentStatement ::= variable ASGN addexpression SEMIC;
ifStatement ::= IF LPAREN booleanExpression RPAREN statement | IF LPAREN booleanExpression RPAREN statement ELSE statement;
whileStatement ::= WHILE LPAREN booleanExpression RPAREN statement;
functionStatement ::= IDENT LPAREN argumentList RPAREN SEMIC;

//LIST
parameterList ::= parameterDeclaration COMMA parameterList | parameterDeclaration |;
statementList ::= statement statementList |;
variableList ::= varDeclaration variableList |;
argumentList ::= addexpression COMMA argumentList| addexpression |;

//OPERATOR
comparisonOperator ::= LT {: RESULT = BinaryExpression.Operator.LST; :}
                     | LE {: RESULT = BinaryExpression.Operator.LSE; :}
                     | GT {: RESULT = BinaryExpression.Operator.GRT; :}
                     | GE {: RESULT = BinaryExpression.Operator.GRE; :}
                     | NE {: RESULT = BinaryExpression.Operator.NEQ; :}
                     | EQ {: RESULT = BinaryExpression.Operator.EQU; :};

//OTHER
addexpression ::= addexpression PLUS mulExpression | addexpression MINUS mulExpression | mulExpression;
mulExpression ::= mulExpression STAR factor | mulExpression SLASH factor | factor;
factor ::= expression | MINUS factor;
expression ::= INTLIT | variable | LPAREN addexpression RPAREN;
variable ::= IDENT | variable LBRACK addexpression RBRACK;
procedure ::= PROC IDENT LPAREN parameterList RPAREN LCURL variableList statementList RCURL;
