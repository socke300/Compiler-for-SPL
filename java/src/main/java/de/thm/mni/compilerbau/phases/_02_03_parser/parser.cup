package de.thm.mni.compilerbau.phases._02_03_parser;

import java_cup.runtime.*;
import de.thm.mni.compilerbau.utils.*;
import de.thm.mni.compilerbau.absyn.*;
import de.thm.mni.compilerbau.table.Identifier;
import de.thm.mni.compilerbau.utils.SplError;

parser code {:
  public void syntax_error(Symbol currentToken) {
    throw SplError.SyntaxError(new Position(currentToken.left, currentToken.right));
  }
:}

/* Terminals/Tokens */
terminal LBRACK, RBRACK, LPAREN, RPAREN, LCURL, RCURL;         //Braces, parenthesis, brackets
terminal LT, LE, GT, GE, NE, EQ;                               //Comparison operators
terminal PLUS, MINUS, STAR, SLASH;                             //Arithmetic operators
terminal ASGN, COMMA, COLON, SEMIC;                            //Other delimiters
terminal TYPE, PROC, ARRAY, OF, REF, VAR, IF, ELSE, WHILE;     //Keywords
terminal Identifier IDENT;                                     //Identifiers
terminal Integer INTLIT;                                       //Integer literals

/* Non-terminals */
non terminal Program program;
non terminal List<GlobalDeclaration> globalDeclarations;
non terminal GlobalDeclaration globalDeclaration;
non terminal TypeDeclaration typeDeclaration;
non terminal ProcedureDeclaration proc;
non terminal List<ParameterDeclaration> parameterList;
non terminal ParameterDeclaration parameterDeclaration;
non terminal CompoundStatement statementList;
non terminal Statement statement;
non terminal Expression expression;
non terminal AssignStatement assignmentStatement;
non terminal BinaryExpression.Operator comparisonOperator;
non terminal factor; //---------------------------------
non terminal IfStatement ifStatement;
non terminal CallStatement procCall;
non terminal List<Expression> argumentList;
non terminal VariableDeclaration varDeclaration;
non terminal WhileStatement whileStatement;
non terminal TypeExpression typeExpression;
non terminal List<Variable> variableList;
non terminal Variable variable;
non terminal Expression addexpression;
non terminal Expression mulExpression;
non terminal BinaryExpression booleanExpression;

//GLOBAL
start with program;
program ::= globalDeclarations:gDec {: RESULT = new Program(new Position(gDecleft,gDecright),gDec);:};
globalDeclarations ::= globalDeclaration globalDeclarations | ;
globalDeclaration ::= typeDeclaration:td {: RESULT = td;:}
                    | proc:p {: RESULT = p;:};



//types
typeDeclaration ::= TYPE IDENT:name EQ typeExpression:te SEMIC {: RESULT = new TypeDeclaration(new Position(nameleft,nameright),name, te);:};
typeExpression ::= ARRAY:ar LBRACK INTLIT:size RBRACK OF typeExpression:base {: RESULT = new ArrayTypeExpression(new Position(arleft,arright), base, size);:}
                 | IDENT:id {: RESULT = new NamedTypeExpression(new Position(idleft,idright), id);:};

//Procs
proc ::= PROC:p IDENT:name LPAREN parameterList:pList RPAREN LCURL variableList:vList statementList:sList RCURL;
parameterList ::= parameterDeclaration COMMA parameterList | parameterDeclaration| ;
parameterDeclaration ::= IDENT:name COLON typeExpression:te {: RESULT =  new ParameterDeclaration(new Position(nameleft,nameright), name, te, false);:}
                        | REF IDENT:name COLON typeExpression:te {: RESULT =  new ParameterDeclaration(new Position(nameleft,nameright), name, te, true);:};

procCall ::= IDENT LPAREN argumentList RPAREN SEMIC;

//Variables
variableList ::= varDeclaration:vD variableList  |;
varDeclaration ::= VAR IDENT COLON typeExpression SEMIC;

//EXPRESSION


booleanExpression ::= addexpression:opl comparisonOperator:op addexpression:opr {: RESULT = new BinaryExpression(new Position(opleft, opright) , op, opl, opr); :};

//STATEMENT
statement ::= assignmentStatement | ifStatement | procCall | LCURL statementList RCURL | SEMIC | whileStatement;
assignmentStatement ::= variable ASGN addexpression SEMIC;
ifStatement ::= IF LPAREN booleanExpression RPAREN statement | IF LPAREN booleanExpression RPAREN statement ELSE statement;
whileStatement ::= WHILE LPAREN booleanExpression RPAREN statement;


//LIST

statementList ::= statement statementList |;

argumentList ::= addexpression COMMA argumentList| addexpression |;

//OPERATOR
comparisonOperator ::= LT {: RESULT = BinaryExpression.Operator.LST; :}
                     | LE {: RESULT = BinaryExpression.Operator.LSE; :}
                     | GT {: RESULT = BinaryExpression.Operator.GRT; :}
                     | GE {: RESULT = BinaryExpression.Operator.GRE; :}
                     | NE {: RESULT = BinaryExpression.Operator.NEQ; :}
                     | EQ {: RESULT = BinaryExpression.Operator.EQU; :};

//OTHER
addexpression ::= addexpression PLUS mulExpression | addexpression MINUS mulExpression | mulExpression;
mulExpression ::= mulExpression STAR factor | mulExpression SLASH factor | factor;
factor ::= expression | MINUS factor;
expression ::= INTLIT | variable | LPAREN addexpression RPAREN;
variable ::= IDENT | variable LBRACK addexpression RBRACK;



