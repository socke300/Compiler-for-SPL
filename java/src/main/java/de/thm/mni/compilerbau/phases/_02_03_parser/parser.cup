package de.thm.mni.compilerbau.phases._02_03_parser;

import java_cup.runtime.*;
import de.thm.mni.compilerbau.utils.*;
import de.thm.mni.compilerbau.absyn.*;
import de.thm.mni.compilerbau.table.Identifier;
import de.thm.mni.compilerbau.utils.SplError;

parser code {:
  public void syntax_error(Symbol currentToken) {
    throw SplError.SyntaxError(new Position(currentToken.left, currentToken.right));
  }
:}

/* Terminals/Tokens */
terminal LBRACK, RBRACK, LPAREN, RPAREN, LCURL, RCURL;         //Braces, parenthesis, brackets
terminal LT, LE, GT, GE, NE, EQ;                               //Comparison operators
terminal PLUS, MINUS, STAR, SLASH;                             //Arithmetic operators
terminal ASGN, COMMA, COLON, SEMIC;                            //Other delimiters
terminal TYPE, PROC, ARRAY, OF, REF, VAR, IF, ELSE, WHILE;     //Keywords
terminal Identifier IDENT;                                     //Identifiers
terminal Integer INTLIT;                                       //Integer literals

/* Non-terminals */
non terminal Program program;
non terminal List<GlobalDeclaration> globalDeclarations;
non terminal GlobalDeclaration globalDeclaration;
non terminal typeDeclaration;
non terminal procDeclaration;
non terminal parameterList;
non terminal parameterDeclaration;
non terminal statementList;
non terminal statement;
non terminal operate;
non terminal assignmentStatement;
non terminal arithmeticOperators;
non terminal comparisonOperator;
non terminal identOrIntlit;
non terminal arrayDeclaration;
non terminal ifStatement;
non terminal comparison;
non terminal functionStatement;
non terminal functioncallParameterList;
non terminal varDeclaration;
non terminal arithmeticOperatorsAndoperateDeclarationOrNot;
non terminal arrayindexDeclaration;
non terminal arrayindexDeclarationList;
non terminal whileStatement;
non terminal typeExpression;
non terminal variableList;
non terminal variable;

//GLOBAL
start with program;
program ::= globalDeclarations;
globalDeclarations ::= globalDeclaration globalDeclarations | ;
globalDeclaration ::= typeDeclaration | procDeclaration;

//DECLARATION
typeDeclaration ::= TYPE IDENT EQ typeExpression SEMIC;
procDeclaration ::= PROC IDENT LPAREN parameterList RPAREN LCURL variableList statementList RCURL;
parameterDeclaration ::= IDENT COLON typeExpression | REF IDENT COLON typeExpression;
varDeclaration ::= VAR IDENT COLON typeExpression SEMIC;
comparison ::= operate comparisonOperator operate;
operate ::= identOrIntlit arithmeticOperatorsAndoperateDeclarationOrNot | IDENT arrayindexDeclarationList arithmeticOperators operate | IDENT arrayindexDeclarationList | LPAREN operate RPAREN arithmeticOperatorsAndoperateDeclarationOrNot;
variable ::= IDENT | variable LBRACK operate RBRACK;

//EXPRESSION
typeExpression ::= ARRAY LBRACK INTLIT RBRACK OF typeExpression | IDENT;

//STATEMENT
statement ::= assignmentStatement | ifStatement | functionStatement | LCURL statementList RCURL | SEMIC | whileStatement;
assignmentStatement ::= variable ASGN operate SEMIC;
ifStatement ::= IF LPAREN comparison RPAREN statement | IF LPAREN comparison RPAREN statement ELSE statement;
whileStatement ::= WHILE LPAREN comparison RPAREN LCURL statementList RCURL;
functionStatement ::= IDENT LPAREN functioncallParameterList RPAREN SEMIC;

//LIST
parameterList ::= parameterDeclaration COMMA parameterList | parameterDeclaration |;
statementList ::= statement statementList |;
variableList ::= varDeclaration variableList |;
functioncallParameterList ::= operate COMMA functioncallParameterList| operate |;
arrayindexDeclarationList ::= LBRACK operate RBRACK arrayindexDeclarationList | LBRACK operate RBRACK;

//OR
identOrIntlit ::= INTLIT | IDENT | MINUS IDENT | MINUS INTLIT;
arithmeticOperatorsAndoperateDeclarationOrNot ::= arithmeticOperators operate |;

//OPERATOR
arithmeticOperators ::= PLUS | MINUS | STAR | SLASH;
comparisonOperator ::= LT | LE | GT | GE | NE | EQ;
